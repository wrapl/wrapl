#
# Required version of omake
#
OMakeVersion(0.9.8.0, 0.9.9.9)

########################################################################
# Building C files.
#
# Copyright (C) 2003-2007 Jason Hickey and Mojave Group
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this file, to deal in the File without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the File, and to permit persons to whom the File
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the File.
#
# THE FILE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# FILE OR THE USE OR OTHER DEALINGS IN THE FILE.

static. =
    GCC_FOUND = $(CheckProg gcc)
    GXX_FOUND = $(and $(GCC_FOUND), $(CheckProg g++))
public.CC = $(if $(GCC_FOUND), gcc, cc)
public.CXX = $(if $(GXX_FOUND), g++, c++)
public.CPP = cpp
public.CFLAGS = -pipe
public.CXXFLAGS = -pipe
public.AR(name) =
    return(ar cq $(name))
public.RANLIB = ranlib
public.LD = ld
public.INCLUDES[] = .
public.INCLUDES_OPT = -I
public.CCOUT = $(array -o)
public.YACC = yacc
public.LEX = lex
public.LIBS =
public.LDFLAGS =
public.LDOUT = $(array -o)
public.RDOCFLAGS =

#public.CC = i586-mingw32msvc-gcc
#public.CXX = i586-mingw32msvc-g++
#public.CPP = i586-mingw32msvc-cpp
#public.AR = i586-mingw32msvc-ar
#public.RANLIB = i586-mingw32msvc-ranlib
#public.LD = i586-mingw32msvc-ld

static. =
	NASM_FOUND = $(CheckProg nasm)
	YASM_FOUND = $(CheckProg yasm)
public.AS = $(if $(YASM_FOUND), yasm, nasm)
#public.AS = yasm
public.ASOUT = $(array -o)
public.ASFLAGS =
public.ASINCLUDES[] = .

public.PREFIXED_ASINCLUDES = $`(addprefix $(INCLUDES_OPT), $(ASINCLUDES))

public.WFLAGS =

public.PREFIXED_INCLUDES = $`(addprefix $(INCLUDES_OPT), $(INCLUDES))

public.CXX_EXTS[] = .cpp .cc .c++

%$(EXT_OBJ): %.c :scanner: scan-c-%.c
    $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -c $(CCOUT)$@ $<

foreach(CXX_EXT, $(CXX_EXTS))
    %$(EXT_OBJ): %$(CXX_EXT) :scanner: scan-cxx-%$(CXX_EXT)
        $(CXX) $(CXXFLAGS) $(PREFIXED_INCLUDES) -c $(CCOUT)$@ $<

    export

%$(EXT_OBJ): %.asm :scanner: scan-asm-%.asm
    $(AS) $(ASFLAGS) $(PREFIXED_ASINCLUDES) $(ASOUT)$@ $<

%$(EXT_OBJ): %.S
    $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -c $(CCOUT)$@ $<

%$(EXT_OBJ): %.wrapl
	$(WCOMP) $< $@ $(WFLAGS)

%.c: %.y
    $(YACC) $<

%.c: %.l
    $(LEX) $<

.PHONY: CGeneratedFilesTarget

public.CGeneratedFiles(files) =
    CGeneratedFilesTarget: $(files)

public.LocalCGeneratedFiles(files) =
    .SCANNER: scan-c-%: $(files)
    .SCANNER: scan-cxx-%: $(files)
	.SCANNER: scan-asm-%: $(files)
    .SCANNER: %$(EXT_OBJ): $(files)
	clean:
		$(rm -f $(files))
    export

.SCANNER: scan-c-%.c: %.c /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
    $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -MM $<

.SCANNER: %$(EXT_OBJ): %.c /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
    $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -MM $<

foreach(CXX_EXT, $(CXX_EXTS))
    .SCANNER: scan-cxx-%$(CXX_EXT): %$(CXX_EXT) /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
        $(CXX) $(CXXFLAGS) $(PREFIXED_INCLUDES) -MM $<

    # Include default rule for backwards-compatibility
    .SCANNER: %$(EXT_OBJ): %$(CXX_EXT) /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
        $(CXX) $(CXXFLAGS) $(PREFIXED_INCLUDES) -MM $<

    export

.SCANNER: scan-asm-%.asm: %.asm /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(ASINCLUDES), $&)
	$(AS) $(ASFLAGS) $(PREFIXED_ASINCLUDES) -M $<

public.StaticCLibrary(name, files) =
	private.OFILES = $(addsuffix $(EXT_OBJ), $(files))
	private.NAME = $(name)$(EXT_LIB)
    
	if $(equal $(OSTYPE), Win32)
		$(NAME): $(OFILES)
			echo $(OFILES) > $@.tmp
			$(AR $@) @$@.tmp
			rm -f $@.tmp
	else
		$(NAME): $(OFILES)
			rm -f $@
			$(AR $@) $(OFILES)
			$(RANLIB) $@

	clean:
		$(rm -f $(OFILES))
		$(rm -f $(NAME))

	.DEFAULT: $(NAME)
	return $(NAME)

public.SharedCLibrary(name, files) =
	private.OFILES = $(addsuffix $(EXT_OBJ), $(files))
	private.NAME = $(name)$(EXT_DLL)
    
	if $(equal $(OSTYPE), Win32)
		$(NAME): $(OFILES)
			$(CC) -shared $(LDOUT)$@ $,(OFILES) $(LDFLAGS)
	else
		$(NAME): $(OFILES)
			$(CC) -shared $(LDOUT)$@ $,(OFILES) $(LDFLAGS)

	clean:
		$(rm -f $(OFILES))
		$(rm -f $(NAME))

	.DEFAULT: $(NAME)
	return $(NAME)

public.LocalCProgram(name, files) =
	private.OFILES = $(addsuffix $(EXT_OBJ), $(files))
	private.NAME   = $(name)$(EXE)
	private.FLAGS = $(filter -%, $(LIBS))
	if $(FLAGS)
		eprintln($""!!! WARNING: the LIBS variable should not include link flags "$(FLAGS)";"")
		eprintln($""!!!          those should go into LDFLAGS"")
		LDFLAGS += $(FLAGS)
		LIBS = $(filter-out -%, $(LIBS))
		export

	if $(filter %$(EXT_LIB), $(LIBS))
		eprintln($""!!! WARNING: the LIBS variable should contain libraries _without_ extensions."")
		LIBS = $(replacesuffixes $(EXT_LIB), $"$(EMPTY)", $(LIBS))
		export

	private.LFILES = $(addsuffix $(EXT_LIB), $(LIBS))

	$(NAME): $(OFILES) $(LFILES)
		$(CC) $(CFLAGS) $(LDOUT)$@ $,(OFILES) $(LFILES) $(LDFLAGS)

	clean:
		rm(-f $(OFILES))
		rm(-f $(NAME))

	.DEFAULT: $(NAME)
	return $(NAME)

public.CProgram(name, files) =
	private.OFILES = $(addsuffix $(EXT_OBJ), $(files))
	private.NAME   = $(name)$(EXE)
	private.FLAGS = $(filter -%, $(LIBS))
	if $(FLAGS)
		eprintln($""!!! WARNING: the LIBS variable should not include link flags "$(FLAGS)";"")
		eprintln($""!!!          those should go into LDFLAGS"")
		LDFLAGS += $(FLAGS)
		LIBS = $(filter-out -%, $(LIBS))
		export

	if $(filter %$(EXT_LIB), $(LIBS))
		eprintln($""!!! WARNING: the LIBS variable should contain libraries _without_ extensions."")
		LIBS = $(replacesuffixes $(EXT_LIB), $"$(EMPTY)", $(LIBS))
		export

	private.LFILES = $(addsuffix $(EXT_LIB), $(LIBS))

	$(NAME): $(OFILES) $(LFILES)
		$(CC) $(CFLAGS) $(LDOUT)$@ $,(OFILES) $(LFILES) $(LDFLAGS)

	clean:
		rm(-f $(OFILES))
		rm(-f $(NAME))
	
	install:
		cp $(NAME) $(INSTALL_BIN)$(basename $(name))$(EXE)
	
	.DEFAULT: $(NAME)
	return $(NAME)

public.WraplModule(module, name) =
	private.NAME = $(OUT_LIB)$(module).wrapl
	private.SOURCE = $(file $(name).wrapl)
	private.XML = $(OUT_DOC)$(module).xml
	private.DOC = $(file $(name).xml)
	
	$(NAME): $(SOURCE)
		mkdir(-p $(dirof $(NAME)))
		cp $(SOURCE) $@
	
	if $(defined DOCS)
		$(NAME): $(XML)
		export
	
	if $(file-exists $(DOC))
		$(XML): $(DOC)
			mkdir(-p $(dirof $(XML)))
			cp $(DOC) $@
		export
	else
		$(XML):
			section
				mkdir(-p $(dirof $(XML)))
				out = $(fopen $(XML), w)
				fprintln($(out), <?xml version="1.0" encoding="UTF-8"?>)
				fprintln($(out), <module path=\"$(module)\">)
				fprintln($(out), </module>)
				close($(out))
		export
    
	clean:
		rm(-f $(NAME))
		rm(-f $(XML))
	
	install:
		cp $(NAME) $(INSTALL_LIB)$(module).wrapl
	
	.DEFAULT: $(NAME)
	return $(NAME)
		

public.RivaModule(module, files) =
	private.NAME = $(OUT_LIB)$(module).riva
	private.RDEF = $(file $(basename $(module)).rdef)
	private.RLINK2 = $(file $(basename $(module)).rlink)
	private.LDSCRIPT = $(if $(target-exists $(RLINK2)), $(RLINK2), $(RDEF))
	private.LIST = $(file $(basename $(module)).lst)
	private.XML = $(OUT_DOC)$(module).xml
	private.SOURCES =
		foreach(name, $(files))
			if $(target-exists $(name).c)
				value $(file $(name).c)
			elseif $(target-exists $(name).cpp)
				value $(file $(name).cpp)
			elseif $(target-exists $(name).asm)
				value $(file $(name).asm)
			elseif $(target-exists $(name).S)
				value $(file $(name).S)
			elseif $(target-exists $(name).wrapl)
				value $(file $(name).wrapl)
	private.OBJECTS =
		foreach(name, $(files))
			if $(target-exists $(name).c)
				value $(name)$(EXT_OBJ)
			elseif $(target-exists $(name).cpp)
				value $(name)$(EXT_OBJ)
			elseif $(target-exists $(name).asm)
				value $(name)$(EXT_OBJ)
			elseif $(target-exists $(name).S)
				value $(name)$(EXT_OBJ)
			elseif $(target-exists $(name).wrapl)
				value $(name)$(EXT_OBJ)

	$(NAME): $(OBJECTS) $(RLINK) $(LDSCRIPT)
		mkdir(-p $(dirof $(NAME)))
		$(RLINK) $(LDFLAGS) -o$@ $(OBJECTS) $(LDSCRIPT) -?$(LIST) -v$(shell $(DEV_BIN)version $(SOURCES))

	if $(defined DOCS)
		$(NAME): $(XML)
		export

	$(XML): $(SOURCES) $(RDOC)
		$(RDOC) -I$(DEV_INC)/gcc -I$(DEV_INC)/nasm/ $(CFLAGS) $(ASFLAGS) -o$(XML) $(RDOCFLAGS) $(module) $(SOURCES)
    
	clean:
		rm(-f $(OBJECTS))
		rm(-f $(NAME))
		rm(-f $(LIST))
		rm(-f $(XML))
	
	install:
		cp $(NAME) $(INSTALL_LIB)$(module).riva
	
	.DEFAULT: $(NAME)
	return $(NAME)

public.RivaModuleAuto(module, files) =
	private.NAME = $(OUT_LIB)$(module).riva
	private.RDEF = $(file $(basename $(module)).rdef)
	private.RLINK2 = $(file $(basename $(module)).rlink)
	private.LDSCRIPT = $(if $(target-exists $(RLINK2)), $(RLINK2), $(RDEF))
	private.LIST = $(file $(basename $(module)).lst)
	private.IMPORTFILE = $(DEV_LIB)$(module).rlink
	private.XML = $(OUT_DOC)$(module).xml
	private.SOURCES =
		foreach(name, $(files))
			if $(target-exists $(name).c)
				value $(file $(name).c)
			elseif $(target-exists $(name).cpp)
				value $(file $(name).cpp)
			elseif $(target-exists $(name).asm)
				value $(file $(name).asm)
			elseif $(target-exists $(name).S)
				value $(file $(name).S)
			elseif $(target-exists $(name).wrapl)
				value $(file $(name).wrapl)
	private.OBJECTS =
		foreach(name, $(files))
			if $(target-exists $(name).c)
				value $(name)$(EXT_OBJ)
			elseif $(target-exists $(name).cpp)
				value $(name)$(EXT_OBJ)
			elseif $(target-exists $(name).asm)
				value $(name)$(EXT_OBJ)
			elseif $(target-exists $(name).S)
				value $(name)$(EXT_OBJ)
			elseif $(target-exists $(name).wrapl)
				value $(name)$(EXT_OBJ)

	$(NAME): $(OBJECTS) $(RLINK) $(LDSCRIPT)
		mkdir(-p $(dirof $(NAME)))
		mkdir(-p $(dirof $(IMPORTFILE)))
		$(RLINK) $(LDFLAGS) -o$@ $(OBJECTS) $(LDSCRIPT) -?$(LIST) -v$(shell $(DEV_BIN)version $(SOURCES))
		section
			out = $(fopen $(IMPORTFILE), w)
			fprintln($(out), module\(\"$(concat $(quote ", "), $(split /, $(module)))\"\))
			foreach(line, $(shella grep export: $(LIST) | sed -e "s/export: \(.*\) -> .*/import(\"\1\")/g"))
				fprintln($(out), $(line))
			close($(out))

	if $(defined DOCS)
		$(NAME): $(XML)
		export

	$(XML): $(SOURCES) $(RDOC)
		$(RDOC) -I$(DEV_INC)/gcc -I$(DEV_INC)/nasm/ $(CFLAGS) $(ASFLAGS) -o$(XML) $(RDOCFLAGS) $(module) $(SOURCES)
    
	clean:
		rm(-f $(OBJECTS))
		rm(-f $(NAME))
		rm(-f $(LIST))
		rm(-f $(XML))
	
	install:
		cp $(NAME) $(INSTALL_LIB)$(module).riva
	
	.DEFAULT: $(NAME)
	return $(NAME)

public.RivaProgram(name, files) =
   private.OFILES = $(addsuffix $(EXT_OBJ), $(files))
   private.NAME   = $(file $(name).riva)
   private.RDEF = $(file $(basename $(name)).rdef)
   private.LIST = $(file $(basename $(name)).lst)

   $(NAME): $(OFILES) $(RLINK) $(RDEF)
       $(RLINK) -o$@ $(OFILES) $(LDFLAGS) $(RDEF) -?$(LIST)
   
   clean:
       rm(-f $(OFILES))
       rm(-f $(NAME))
       rm(-f $(LIST))
   
   return $(name).riva
