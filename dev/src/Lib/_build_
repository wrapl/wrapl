ASFLAGS = extend(ASFLAGS, "-I", DEV_INC/"nasm/")
CFLAGS = extend(CFLAGS, "-I", DEV_INC/"gcc/", "-fdata-sections", "-ffunction-sections", "-Wstrict-aliasing", "-fno-pic", "-ftls-model=global-dynamic", "-w")
CXXFLAGS = extend(CXXFLAGS, "-fdata-sections", "-ffunction-sections", "-Wstrict-aliasing", "-fno-pic", "-ftls-model=global-dynamic", "-w")
LDFLAGS = extend(LDFLAGS, "-DLINUX", "-L", DEV_LIB, "Gcc.rlink", "libc.rlink", "libm.rlib", "-L/usr/lib/i386-linux-gnu/", "-L/usr/lib/")

--CFLAGS = extend(CFLAGS, "-std=gnu99")

function rlink_includes(Source)
	local Files = {}
	local Lines = shell{RLINK, "-M", LDFLAGS, Source, "-v0"}
	for File in Lines:gmatch("\t(%S*)\n") do
		table.insert(Files, file(File))
	end
	return Files
end


function riva_module(Name, Objects, Libraries)
	local Module = OUT_LIB/Name % "riva"
	execute{"mkdir", "-p", Module:dir()}
	for I, Object in ipairs(Objects) do
		local SourceC = Object % "c"
		local SourceAsm = Object % "asm"
		local SourceGo = Object % "go"
		local SourceAs = Object % "S"
		if lfs.attributes(tostring(SourceC)) then
			local ScanC = SourceC:scan("INCLUDES", c_includes)
			Object{SourceC, ScanC}:build(c_compile)
		elseif lfs.attributes(tostring(SourceAsm)) then
			local ScanAsm = SourceAsm:scan("INCLUDES", asm_includes)
			Object{SourceAsm, ScanAsm}:build(asm_compile)
		elseif lfs.attributes(tostring(SourceAs)) then
			local ScanAs = SourceAs:scan("INCLUDES", as_includes)
			Object{SourceAs, ScanAs}:build(as_compile)
		elseif lfs.attributes(tostring(SourceGo)) then
			local ScanGo = SourceGo:scan("INCLUDES", go_includes)
			Object{SourceGo, ScanGo}:build(go_compile)
		end
	end
	local Script = file(Module:basename()) % "rlink"
	if not lfs.attributes(tostring(Script)) then
		Script = file(Module:basename()) % "rdef"
	end
	local ScriptIncludes = Script:scan("INCLUDES", rlink_includes)
	Module{RLINK, Script, Objects, Libraries, ScriptIncludes}:build(function(Module)
		execute{RLINK, LDFLAGS, "-o", Module, Objects, Libraries, Script, "-v0", "-?", Script % "lst"}
	end)
	DEFAULT{Module}
	return Module
end

function wrapl_module(Name)
	local Module = OUT_LIB/Name % "wrapl"
	execute{"mkdir", "-p", Module:dir()}
	local Source = file(Module:basename())
	Module{Source}:build(function(Module)
		execute{"cp", Source, Module}
	end)
	DEFAULT{Module}
	return Module
end

function riva_program(Executable, Objects, Libraries)
	for I, Object in ipairs(Objects) do
		local SourceC = Object % "c"
		local SourceAsm = Object % "asm"
		local SourceAs = Object % "S"
		if lfs.attributes(tostring(SourceC)) then
			local ScanC = SourceC:scan("INCLUDES", c_includes)
			Object{SourceC, ScanC}:build(c_compile)
		elseif lfs.attributes(tostring(SourceAsm)) then
			local ScanAsm = SourceAsm:scan("INCLUDES", asm_includes)
			Object{SourceAsm, ScanAsm}:build(asm_compile)
		elseif lfs.attributes(tostring(SourceAs)) then
			local ScanAs = SourceAs:scan("INCLUDES", as_includes)
			Object{SourceAs, ScanAs}:build(as_compile)
		end
	end
	local Script = file(Executable:basename()) % "rlink"
	if not lfs.attributes(tostring(Script)) then
		Script = file(Executable:basename()) % "rdef"
	end
	if not lfs.attributes(tostring(Script)) then
		Script = nil
	end
	Executable{RLINK, Script, Objects, Libraries}:build(function(Executable)
		execute{RLINK, LDFLAGS, "-o", Executable, Objects, Libraries, Script, "-v0", "-?", Executable % "lst"}
	end)
end

function pkg_config(Options)
	local S = shell{"pkg-config", Options}
	return (S:gsub("^%s*(.-)%s*$", "%1"))
end

subdir("Lib")
subdir("Std")
subdir("Sys")
subdir("IO")
subdir("Util")
subdir("Agg")
subdir("Alg")
subdir("Wrapl")
subdir("Web")
subdir("Gir")
subdir("Snd")
subdir("Json")
subdir("Xml")
subdir("Csv")
subdir("DB")
subdir("Math")
--subdir("Tst")
